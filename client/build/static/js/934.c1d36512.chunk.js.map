{"version":3,"file":"static/js/934.c1d36512.chunk.js","mappings":"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","sources":["components/withRouter.js","pages/shop/shop.component.js","../node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../node_modules/framer-motion/dist/es/utils/use-force-update.mjs","../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","../node_modules/framer-motion/dist/es/context/PresenceContext.mjs","../node_modules/framer-motion/dist/es/utils/is-browser.mjs","../node_modules/framer-motion/dist/es/utils/use-constant.mjs","../node_modules/framer-motion/dist/es/utils/use-id.mjs","../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs","../node_modules/framesync/dist/es/on-next-frame.mjs","../node_modules/framesync/dist/es/index.mjs","../node_modules/framesync/dist/es/create-render-step.mjs"],"sourcesContent":["import { useNavigate, useLocation, useParams } from \"react-router-dom\";\n\nexport const withRouter = (Component) => {\n  const Wrapper = (props) => {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const params = useParams();\n\n    return (\n      <Component\n        navigate={navigate}\n        location={location}\n        params={params}\n        {...props}\n      />\n    );\n  };\n\n  return Wrapper;\n};\n","import React, { useEffect, lazy, Suspense } from \"react\";\nimport { Route, Routes } from \"react-router-dom\";\nimport { withRouter } from \"../../components/withRouter\";\nimport { fetchCollectionsStart } from \"../../redux/shop/shop.actions\";\nimport { useDispatch } from \"react-redux\";\nimport Spinner from \"../../components/spinner/spinner.component\";\nimport { AnimatePresence } from \"framer-motion\";\n\nconst CollectionsOverviewContainer = lazy(() =>\n  import(\"../../components/collections-overview/collections-overview.container\")\n);\nconst CollectionPageContainer = lazy(() =>\n  import(\"../collection/collection.container\")\n);\n\nconst ItemPageContainer = lazy(() => import(\"../item/item.container\"));\n\nconst ShopPage = ({ location }) => {\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    dispatch(fetchCollectionsStart());\n  }, [dispatch]);\n\n  return (\n    <div className='shop-page'>\n      <Suspense fallback={<Spinner />}>\n        <AnimatePresence exitBeforeEnter>\n          <Routes location={location} key={location.pathname}>\n            <Route exact path={``} element={<CollectionsOverviewContainer />} />\n            <Route\n              path={`/:categoryId`}\n              element={<CollectionPageContainer />}\n            />\n            <Route\n              path={`/:categoryId/:itemId`}\n              element={<ItemPageContainer key={location.pathname} />}\n            />\n          </Routes>\n        </AnimatePresence>\n      </Suspense>\n    </div>\n  );\n};\n\nexport default withRouter(ShopPage);\n","import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    var isMounted = useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n","import { __values } from 'tslib';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useId } from '../../utils/use-id.mjs';\n\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            var e_1, _a;\n            presenceChildren.set(childId, true);\n            try {\n                for (var _b = __values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var isComplete = _c.value;\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\n\nvar getChildKey = function (child) { return child.key || \"\"; };\nvar isDev = process.env.NODE_ENV !== \"production\";\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = isDev ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (isDev && seenChildren && seenChildren.has(key)) {\n            console.warn(\"Children of AnimatePresence require unique keys. \\\"\".concat(key, \"\\\" is a duplicate.\"));\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(function () {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function () {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n","import { __read } from 'tslib';\nimport sync from 'framesync';\nimport { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\n\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = useCallback(function () {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    var deferredForceRender = useCallback(function () { return sync.postRender(forceRender); }, [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n","import { createContext } from 'react';\n\n/**\n * @internal\n */\nvar LayoutGroupContext = createContext({});\n\nexport { LayoutGroupContext };\n","import { createContext } from 'react';\n\n/**\n * @public\n */\nvar PresenceContext = createContext(null);\n\nexport { PresenceContext };\n","var isBrowser = typeof window !== \"undefined\";\n\nexport { isBrowser };\n","import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n","import { useConstant } from './use-constant.mjs';\n\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useId = function () { return useConstant(incrementId); };\n/**\n * Ideally we'd use the following code to support React 18 optionally.\n * But this fairly fails in Webpack (otherwise treeshaking wouldn't work at all).\n * Need to come up with a different way of figuring this out.\n */\n// export const useId = (React as any).useId\n//     ? (React as any).useId\n//     : () => useConstant(incrementId)\n\nexport { useId };\n","import { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\n\nvar useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n\nexport { useIsomorphicLayoutEffect };\n","import { useEffect } from 'react';\n\nfunction useUnmountEffect(callback) {\n    return useEffect(function () { return function () { return callback(); }; }, []);\n}\n\nexport { useUnmountEffect };\n","const defaultTimestep = (1 / 60) * 1000;\nconst getCurrentTime = typeof performance !== \"undefined\"\n    ? () => performance.now()\n    : () => Date.now();\nconst onNextFrame = typeof window !== \"undefined\"\n    ? (callback) => window.requestAnimationFrame(callback)\n    : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\nexport { defaultTimestep, onNextFrame };\n","import { onNextFrame, defaultTimestep } from './on-next-frame.mjs';\nimport { createRenderStep } from './create-render-step.mjs';\n\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst frame = {\n    delta: 0,\n    timestamp: 0,\n};\nconst stepsOrder = [\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => (runNextFrame = true));\n    return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n        if (!runNextFrame)\n            startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = steps[key].cancel;\n    return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = () => steps[key].process(frame);\n    return acc;\n}, {});\nconst processStep = (stepId) => steps[stepId].process(frame);\nconst processFrame = (timestamp) => {\n    runNextFrame = false;\n    frame.delta = useDefaultElapsed\n        ? defaultTimestep\n        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n    frame.timestamp = timestamp;\n    isProcessing = true;\n    stepsOrder.forEach(processStep);\n    isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        onNextFrame(processFrame);\n    }\n};\nconst startLoop = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!isProcessing)\n        onNextFrame(processFrame);\n};\nconst getFrameData = () => frame;\n\nexport default sync;\nexport { cancelSync, flushSync, getFrameData };\n","function createRenderStep(runNextFrame) {\n    let toRun = [];\n    let toRunNextFrame = [];\n    let numToRun = 0;\n    let isProcessing = false;\n    let flushNextFrame = false;\n    const toKeepAlive = new WeakSet();\n    const step = {\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        process: (frameData) => {\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            toRunNextFrame.length = 0;\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"names":["withRouter","Component","props","navigate","useNavigate","location","useLocation","params","useParams","CollectionsOverviewContainer","lazy","CollectionPageContainer","ItemPageContainer","dispatch","useDispatch","useEffect","fetchCollectionsStart","className","Suspense","fallback","exitBeforeEnter","exact","path","element","pathname","useIsMounted","isMounted","useRef","useIsomorphicLayoutEffect","current","PresenceChild","_a","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","presenceChildren","useConstant","newChildrenMap","id","useId","context","useMemo","childId","e_1","set","_b","__values","values","_c","next","done","value","e_1_1","error","return","call","register","delete","undefined","forEach","_","key","React","size","PresenceContext","Map","getChildKey","child","AnimatePresence","_d","__read","useState","forcedRenderCount","setForcedRenderCount","forceRender","useCallback","sync","useForceUpdate","forceRenderLayoutGroup","useContext","LayoutGroupContext","filteredChildren","filtered","Children","isValidElement","push","onlyElements","childrenToRender","exiting","Set","presentChildren","allChildren","isInitialRender","updateChildLookup","useUnmountEffect","clear","map","__spreadArray","presentKeys","targetKeys","numPresent","length","i","indexOf","add","get","insertionIndex","splice","removeIndex","findIndex","presentChild","has","cloneElement","createContext","isBrowser","window","init","ref","counter","incrementId","useLayoutEffect","callback","defaultTimestep","getCurrentTime","performance","now","Date","onNextFrame","requestAnimationFrame","setTimeout","useDefaultElapsed","runNextFrame","isProcessing","frame","delta","timestamp","stepsOrder","steps","reduce","acc","toRun","toRunNextFrame","numToRun","flushNextFrame","toKeepAlive","WeakSet","step","schedule","addToCurrentFrame","buffer","cancel","index","process","frameData","createRenderStep","keepAlive","immediate","startLoop","cancelSync","flushSync","processStep","stepId","processFrame","Math","max","min","getFrameData"],"sourceRoot":""}